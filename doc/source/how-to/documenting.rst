Documenting
===========
PyAnsys documentation must not only be written but also maintained. If you are
new to writing developer documentation, see the `Google Developer Documentation
Style Guide <https://developers.google.com/style>`_. It provides
editorial guidelines for writing clear and consistent developer documentation,
allowing this guide to supply guidance only specific to PyAnsys library
documentation.

When writing developer documentation, the relationship between code and
documentation is key. To keep documentation up to date with evolving
code:

- Minimize the content footprint.
- Write `timeless documentation <https://developers.google.com/style/timeless-documentation>`_.
- Support contributions from both inside and outside of the development team.
- Perform periodic reviews.

Documentation Sources
---------------------
.. raw:: html
    
    <div align="center">
      <img src="https://github.com/sphinx-doc/sphinx/raw/5.x/doc/_static/sphinx.png">
    </div>
    <br>

The generation of PyAnsys documentation uses `Sphinx
<https://www.sphinx-doc.org/en/master/>`__ and an Ansys-branded theme
(`ansys-sphinx-theme <https://github.com/ansys/Sansys-sphinx-theme>`_) to
assemble content in:

- Docstrings
- reStructuredText (RST) files
- Python (PY) example files

Docstrings
~~~~~~~~~~
Docstrings must be formatted so that Sphinx can parse them. You can use either
of these Sphinx extensions:
 
- `numpydoc <https://pypi.org/project/numpydoc/>`_
- `napoleon <https://pypi.org/project/sphinxcontrib-napoleon/>`_

The ``numpydoc`` extension is generally preferred because it supports an API
documentation structure with one page per method, providing Python community
members with documentation like that generated by `pandas <https://pandas.pydata.org/>`_
and `NumPy <https://numpy.org/>`_. If, however, your API is very linear, you
might prefer the ``napoleon`` extension because it supports a documentation
structure where everything needed to solve a certain problem can be shown on one page.

The ``numpydoc`` extension provides its own `style guide
<https://numpydoc.readthedocs.io/en/latest/format.html>`_ and a `user guide
<https://numpydoc.readthedocs.io/en/latest/>`_ that explains how to use the
extension with Sphinx. The ``napoleon`` extension, which parses both numpy and
Google style docstrings, refers you to the `Google Python Style Guide
<https://google.github.io/styleguide/pyguide.html>`_.

Regardless of the extension that you choose for generating documentation, using
numpy-style docstrings ensures that there is consistency within PyAnsys libraries.
For more information, see :ref:`Documentation Style`.

ReStructured Text Files
~~~~~~~~~~~~~~~~~~~~~~~
To provide general usage information in your documentation, use your favorite
editor to create ReStructured Text (RST) files that you then place in :ref:`The \`\`doc/\`\`
Directory` directory. The ``index.rst`` file in the ``doc/source`` directory
defines the first level of your documentation hierarchy.  The ``toctree``
directive (which stands for "table of contents tree") indicates the maximum
number of heading levels that the documentation is to display. Below this
directive are the directory names for your documentation sections.

.. include:: diag/doc_layout.rst

Each documentation chapter has its own ``index.rst`` file, as shown by figure
:numref:`proposed doc layout`. Previous documentation layout can be modelled
using the following code in each one of the ``index.rst`` files.

.. tabs::

    .. tab:: index.rst

        .. code-block:: rst

            Welcome to the Library Documentation
            ####################################

            This is the content of the root `index.rst` file.

            .. toctree::

                chapter_A/index
                chapter_B/index

    .. tab:: chapter_A/index.rst

        .. code-block:: rst

            Chapter A
            #########

            This is the content of the `chapter_A/index.rst` file.

            .. toctree::

                section_1
                section_2
                ...

    .. tab:: chapter_B/index.rst

        .. code-block:: rst

            Chapter B
            #########

            This is the content of the `chapter_B/index.rst` file.

            .. toctree::

                another_section
                ...

While you do not include the ``.rst`` extension when defining the section
structure, the index file referenced for each chapter must be named
``index.rst``.

After you build documentation locally as described in :ref:`Building
Documentation`, the first-level heading in the ``index.rst`` file for each
documentation chapter is shown as a clickable link in the header of the
documentation's generated HTML output. For more information on defining a
documentation structure, see the `Sphinx Getting Started
<https://www.sphinx-doc.org/en/master/usage/quickstart.html>`_ guide.

Indicating RST Titles
+++++++++++++++++++++
Within RST files, heading titles are followed by a line having a string of
characters that is the same length as the heading title. If the length of the
characters under the heading title do not match the length of the heading
title, Sphinx generates a warning.

For consistency within PyAnsys libraries, the use of these special characters
is recommended for headings but is not enforced:

- For chapter-level headings, use ``###``.
- For section-level headings, use ``===``.
- For subsection-level headings, use ``---``.
- For subsubsection-level headings, use ``~~~``. 
- For paragraph-level headings, use ``+++``. 

For comprehensive syntax information, see the `reStrucutredText Markup Specification
<https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html>`_.

Because you need to be familiar with the content in the `PyAnsys Developer's
Guide <dev.docs.pyansys.com/>`_, page through its HTML pages and then explore
the RST files in its repository. This will help you to understand the syntax and
see how RST files have been nested to create this developer's guide.

Recommended Chapters
++++++++++++++++++++
Although each project is different, documentation has the same goal: providing
instructions and guidelines for users. Thus, some common chapters can be
found across software projects. Try to include these chapters in your project:

- ``Getting Started`` contains guidelines on how to install and set up the library.
- ``User Guide`` demonstrates some of the basic features of the library.
- ``API Reference`` documents the different objects of the library.
- ``Examples`` provides fully fledged tutorials and use cases for the library.


Examples
~~~~~~~~
Examples come in two formats:

- Basic code snippets demonstrating functionality
- Full-fledged standalone examples that are meant to be run as downloadable scripts

Place basic code snippets in the ``doc/source/`` directory.
Place full-fledged standalone examples in the ``examples/`` directory
at the root of the repository. All of these examples, which should be compliant
with :ref:`PEP 8`, are compiled dynamically during the build process. Always ensure
that your examples run properly locally because they will be verified through
the CI performed via GitHub Actions.

Adding a new standalone example consists of placing it in an applicable
subdirectory in the ``examples/`` directory. If none of the existing directories
match the category of your example, create a new subdirectory with a
``README.txt`` file describing the new category. Because these examples are
built using the `Sphinx-Gallery
<https://sphinx-gallery.github.io/stable/index.html>`_ extension, you must
follow its `coding guidelines
<https://sphinx-gallery.github.io/stable/index.html>`_.

PyMAPDL provides a self-demonstrating example of how to `add an example
reference key
<https://mapdldocs.pyansys.com/examples/03-tips-n-tricks/00-example-template.html#ref-how-to-add-an-example-reference-key>`_. 


Documenting Python Code
-----------------------
You can use `sphinx.ext.autodoc` to document your Python code. When using this
extension, you can include the following directives in your :ref:`ReStructured
Text Files`:

* ``automodule`` for documenting modules
* ``autoclass`` for documenting classes
* ``autofunction`` for documenting functions

For a full list of auto-directives, see `Include Documentation From Docstrings
<https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_.


Documenting Classes
~~~~~~~~~~~~~~~~~~~
There are two main ways of using Sphinx to document a class:

* Manually describe 'how' and 'why' to use a class in either a ``User Guide`` or
  an example within the library's documentation.

* Automatically generate documentation for classes using the ``autoclass`` or
  ``autosummary`` directive.

Manual Documentation
++++++++++++++++++++
To manually describe 'how' and 'why' to exercise a class, use the ``code-block``
directive:

.. tabs::

    .. tab:: Doc Source Code

        .. code-block:: rst
        
            Initialize ``my_module.MyClass`` with initial parameters. These
            parameters are automatically assigned to the class.
        
            .. code-block:: pycon
        
               >>> from my_module import MyClass
               >>> my_obj = MyClass(parm1='apple', parm2='orange')
               >>> my_obj.parm1
               'apple'

    .. tab:: Rendered Doc

        Initialize ``my_module.MyClass`` with initial parameters. These
        parameters are automatically assigned to the class.
        
        .. code-block:: pycon
        
           >>> from my_module import MyClass
           >>> my_obj = MyClass(parm1='apple', parm2='orange')
           >>> my_obj.parm1
           'apple'

Auto-generated Documentation
++++++++++++++++++++++++++++
To automatically generate class descriptions, use either the ``autoclass``
or ``autosummary`` directive.

For simple classes, use the ``autoclass`` directive:


.. tabs::

    .. tab:: Doc Source Code

        .. code-block:: rst

            .. autoclass:: ansys_sphinx_theme.samples.ExampleClass
               :members:

    .. tab:: Rendered Doc

        .. autoclass:: ansys_sphinx_theme.samples.ExampleClass
            :members:


For complex classes with many methods, use the
``autosummary`` directive:

.. tabs:: 

    .. tab:: Doc Source Code

        .. code-block:: rst

            .. autoclass:: ansys_sphinx_theme.samples.Complex

            .. autosummary::
               :toctree: api/

               ansys_sphinx_theme.samples.Complex.real
               ansys_sphinx_theme.samples.Complex.imag
               ansys_sphinx_theme.samples.Complex.abs

    .. tab:: Rendered Doc

        .. autoclass:: ansys_sphinx_theme.samples.Complex
        
        .. autosummary::

           ansys_sphinx_theme.samples.Complex.real
           ansys_sphinx_theme.samples.Complex.imag
           ansys_sphinx_theme.samples.Complex.abs


Documenting Multiple Classes
++++++++++++++++++++++++++++
To document a set of small but highly cohesive classes, an option is to combine
the two approaches described above. This is done by including multiple
``autoclass`` directives on the same page with headings and text blocks as
necessary to describe the relationships between the classes.

For example, the Granta MI BoM Analytics library uses this combined approach:
:external+grantami-bomanalytics:doc:`Part Compliance page <api/compliance/parts>`
first describes the
:external+grantami-bomanalytics:class:`~ansys.grantami.bomanalytics.queries.PartComplianceQuery`
class. It then describes the
:external+grantami-bomanalytics:class:`~ansys.grantami.bomanalytics._query_results.PartComplianceQueryResult`,
and
:external+grantami-bomanalytics:class:`~ansys.grantami.bomanalytics._item_results.PartWithComplianceResult`
classes returned by the query. Because the classes are only ever
encountered together in this context, they are documented on a
single page.

In contrast, the
:external+grantami-bomanalytics:class:`~ansys.grantami.bomanalytics.indicators.RoHSIndicator`
and
:external+grantami-bomanalytics:class:`~ansys.grantami.bomanalytics.indicators.WatchListIndicator`
classes are shared across multiple queries. Consequently, they are
documented separately.


Building Documentation
----------------------
`Sphinx <https://www.sphinx-doc.org/en/master/>`_ is used to build the documentation.
You configure the entire build process in the ``conf.py`` file, located in the
``source/`` directory in :ref:`The \`\`doc/\`\` Directory`.

This directory also contains a ``Makefile`` file and a ``make.bat`` file for
automating the building process. Different builders render different
documentation output, such as ``HTML``, ``LaTeX`` or
``PDF``. 

Building HTML documentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~
You build ``HTML`` documentation with:

.. tabs::

    .. group-tab:: Makefile

        .. code-block:: bash

            make html

    .. group-tab:: make.bat

        .. code-block:: bash

            make.bat html

The resulting ``HTML`` files are created in the ``_build/html`` directory,
located in :ref:`The \`\`doc/\`\` Directory`.

You can display the HTML documentation with:

.. code-block:: text

    <browser> doc/_build/html/index.html

Building PDF Documentation
~~~~~~~~~~~~~~~~~~~~~~~~~~
To  build ``PDF`` documentation, the following rules must be added to
``Makefile`` and ``make.bat`` files:

.. tabs::

    .. group-tab:: Makefile

        .. code-block:: text
            
            pdf:
	            @$(SPHINXBUILD) -M latex "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
	            cd build/latex && latexmk -r latexmkrc -pdf *.tex -interaction=nonstopmode || true
	            (test -f build/latex/*.pdf && echo pdf exists) || exit 1

    .. group-tab:: make.bat

        .. code-block:: text

           :pdf
                   %SPHINXBUILD% -M latex %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
	           cd "%BUILDDIR%\latex"
	           pdflatex \*.tex --interaction=nonstopmode

You can call previous rules by running:

.. tabs::

    .. group-tab:: Makefile

        .. code-block:: bash

            make pdf

    .. group-tab:: make.bat

        .. code-block:: bash

            make.bat pdf

The resulting PDF and intermediate LaTeX files are created in the
``_build/latex`` folder, located in :ref:`The \`\`doc/\`\` Directory`.

.. admonition:: Always check the content of your PDF file.

   Because warnings and errors that occur during the LaTeX building and rendering
   processes are ignored, it is possible that the PDF file has text formatting errors.

Deploying Documentation
-----------------------
PyAnsys libraries deploy their documentation online via `GitHub Actions`_ to
`GitHub Pages`_. For example, this documentation is hosted on the `gh-pages`_
branch within this repository. This is done by uploading the generated
documentation within the ``doc/_build/html/`` directory directly to the
``gh-pages`` branch and then `enabling GitHub pages`_.

Building Your Documentation within GitHub
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
While you could manually upload your auto-generated documentation for each
release using your own local GitHub credentials, the best practice is to have
your documentation build on GitHub and deployed either on release or push to
main. You can do this via `GitHub Actions`_ by creating a new workflow that
generates your documentation on each pull request and then deploys under
certain conditions.

Documentation Workflow
++++++++++++++++++++++
Your documentation workflow should be in the ``.github/workflows``
directory and should be triggered on each PR. It should use one of the
following approaches:

.. tabs::

    .. group-tab:: Using ``tox``

        The best way to get started with ``tox`` is to use the `ansys-templates`_ tool and run:

        .. code-block:: text

            ansys-templates new pyansys-advanced

        This will generate a new GitHub workflow file containing the following section:

        .. code-block:: yaml

            docs:
              name: Documentation
              runs-on: ubuntu-latest
              steps:
                - uses: actions/checkout@v2
                - name: Set up Python
                  uses: actions/setup-python@v2
                  with:
                    python-version: 3.7
                - name: Install dependencies
                  run: |
                    python -m pip install --upgrade pip flit tox
                - name: Generate the documentation with tox
                  run: tox -e doc

    .. group-tab:: Without Using ``tox``

        While `tox`_ is the preferred tool for automating your documentation build, if
        you want to avoid using `tox`_, consider the following workflow:

        .. code-block:: yaml

            docs:
              name: Build Documentation
              runs-on: ubuntu-latest
              steps:
                - uses: actions/checkout@v2
                - name: Setup Python
                  uses: actions/setup-python@v2
                  with:
                    python-version: 3.8

                - name: Install <PROJECT-NAME>
                  run: pip install .

                - name: Install documentation build requirements
                  run: pip install -r requirements/requirements_docs.txt

                - name: Build Documentation
                  run: |
                    make -C doc html SPHINXOPTS="-j auto -W --keep-going"
                    touch doc/_build/html/.nojekyll
                    <product>.docs.pyansys.com > doc/_build/html/CNAME


Your next step will be to upload the documentation artifact. Assuming your
documentation is written to ``doc/_build/html``, upload your documentation
with:

.. tabs::

    .. group-tab:: Using ``tox``

        .. code-block:: yaml
        
            - name: Upload HTML Documentation
              uses: actions/upload-artifact@v2
              with:
                name: HTML-Documentation
                path: .tox/doc_out/
                retention-days: 7

    .. group-tab:: Without Using ``tox``

        .. code-block:: yaml
        
            - name: Upload HTML Documentation
              uses: actions/upload-artifact@v2
              with:
                name: HTML-Documentation
                path: doc/_build/html
                retention-days: 7

This allows anyone creating pull requests to download documentation build
artifacts as a convenient zip and to open the documentation by opening
``index.html``.


Deploying to GitHub Pages
+++++++++++++++++++++++++
Next, deploy your documentation to the ``gh-pages`` branch via using the
`JamesIves/github-pages-deploy-action
<https://github.com/JamesIves/github-pages-deploy-action>`_ action.

.. admonition:: Deploying to another repository.

   If you are planning to deploy documentation to another repository rather than
   the one for your project, make sure you create this new repo before deploying
   for the first time your documentation.

The following job step shows the logic for deploying. If you wish to deploy to
another repository, make sure to uncomment the ``repository-name`` line and
declare the name of your documentation repository:

.. tabs::

    .. group-tab:: Using ``tox``

        .. code-block:: yaml
        
            - name: Deploy
              if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
              uses: JamesIves/github-pages-deploy-action@4.3.0
              with:
                token: ${{ secrets.GITHUB_TOKEN }}
                # repository-name: pyansys/repository-name
                branch: gh-pages
                folder: .tox/doc_out
                clean: true

    .. group-tab:: Without Using ``tox``

        .. code-block:: yaml

            - name: Deploy
              if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
              uses: JamesIves/github-pages-deploy-action@4.3.0
              with:
                token: ${{ secrets.GITHUB_TOKEN }}
                # repository-name: pyansys/repository-name
                branch: gh-pages
                folder: doc/_build/html
                clean: true


Notice that for previous job steps, a ``GITHUB_TOKEN`` is required. Github
automatically generates the token ``GITHUB_TOKEN`` which you can use as
``token`` for deploying documentation to the same repo. However, if you are
planning to deploy to another repo this token does not have the permissions to
do it.

In that case, there are two options for documentation deployment, using a bot
and using a personal access token (PAT). Depending on your profile (how many
organizations you work in, the rights in the different repositories, etc), using
a PAT can be potentially dangerous because PAT are not restricted to defined
repositories, rather have general permissions. This means that a PAT with
`repository-write` permission can write in any repo in any organization that the
PAT creator can access.

Therefore, the recommended approach is to **use a Bot**. However, you are free
to use a PAT if you feel it fits your needs better.


Deploying by Using a Bot
""""""""""""""""""""""""
To deploy documentation to repo different than the one where the documentation
is generated, you need permissions to access (*read/write*) this second repo.
These permissions can be handled using a specifically created bot. In PyAnsys
organization, there is `PyAnsys Bot`_ which has read and write permission across
some repositories and can be used for this purpose.

.. admonition:: Organization approval to use PyAnsys bot

    You need internal approval to use PyAnsys bot as your repo needs to added to
    its list of repositories.
    Please email `PyAnsys Support <pyansys.support@ansys.com>`_.


Once your repository has been added to the bot repositories white-list, you need to add the
following code to your CICD YAML file for the authentication:

.. tabs::

    .. group-tab:: Using ``tox``

        .. code-block:: yaml

          - name: Get Bot Application Token
            if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
            id: get_workflow_token
            uses: peter-murray/workflow-application-token-action@v1
            with:
              application_id: ${{ secrets.BOT_APPLICATION_ID }}
              application_private_key: ${{ secrets.BOT_APPLICATION_PRIVATE_KEY }}


    .. group-tab:: Without Using ``tox``

        .. code-block:: yaml

          - name: Get Bot Application Token
            if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
            id: get_workflow_token
            uses: peter-murray/workflow-application-token-action@v1
            with:
              application_id: ${{ secrets.BOT_APPLICATION_ID }}
              application_private_key: ${{ secrets.BOT_APPLICATION_PRIVATE_KEY }}


and the following for the documentation deployment:

.. tabs::

    .. group-tab:: Using ``tox``

        .. code-block:: yaml
        
            - name: Deploy
              if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
              uses: JamesIves/github-pages-deploy-action@4.3.0
              with:
                token: ${{ steps.get_workflow_token.outputs.token }}
                repository-name: pyansys/repository-name
                branch: gh-pages
                folder: .tox/doc_out
                clean: true

    .. group-tab:: Without Using ``tox``

        .. code-block:: yaml

            - name: Deploy
              if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
              uses: JamesIves/github-pages-deploy-action@4.3.0
              with:
                token: ${{ steps.get_workflow_token.outputs.token }}
                repository-name: pyansys/repository-name
                branch: gh-pages
                folder: doc/_build/html
                clean: true



Deployin by Using a Personal Access Token
"""""""""""""""""""""""""""""""""""""""""
To setup the documentation deployment using a Personal Access Token (PAT), you
need to create a personal access token first in the ``Settings`` section in your
GitHub profile. In the left side bar, select the ``Developer Settings`` section
and then ``Personal access tokens``. Finally, click ``Generate new token`` and
give it ``write`` permissions on ``Repositories`` at least. You will be prompted
with the value of the ``TOKEN``. Make sure to copy the value of the ``TOKEN`` as
you will not be able to retrieve it later. Finally, click ``Configure SSO`` to
allow using it with the PyAnsys repositories you have access to.

.. note::

    In some cases, the authentication might need specific approval. If you do
    still get authentication errors like those that follow, click the link in
    the log to authorize the workflow.
    
    .. code-block:: text
        :emphasize-lines: 1,2,9
        
        remote: The `pyansys' organization has enabled or enforced SAML SSO. To access
        remote: this repository, visit https://github.com/orgs/pyansys/sso?            authorization_request=AGWYQUM5VKPHAQHRS2H3JNTCVBNE7A5PN5ZGOYLONF5GC5DJN5XF62LEZYB663VUVVRX      EZLEMVXHI2LBNRPWSZGOGU33VEFPMNZGKZDFNZ2GSYLML52HS4DFVNHWC5LUNBAWGY3FONZQ
        remote: and try your request again.
        fatal: unable to access 'https://github.com/pyansys/pynexus-dev-docs.git/': The requested URL returned error: 403
        Running post deployment cleanup jobs‚Ä¶ üóëÔ∏è
        /usr/bin/git checkout -B github-pages-deploy-action/x00pqaqlu
        Reset branch 'github-pages-deploy-action/x00pqaqlu'
        /usr/bin/chmod -R 777 github-pages-deploy-action-temp-deployment-folder
        /usr/bin/git worktree remove github-pages-deploy-action-temp-deployment-folder --force
        Error: The deploy step encountered an error: The process '/usr/bin/git' failed with exit code 128 ‚ùå
      

Paste the value of the token in the ``Settings/Secrets/Actions`` path under a
new secret named ``DEPLOY_DOCS_PAT`` in the repository of the project. Use this
secret in your CI/CD:

.. tabs::

    .. group-tab:: Using ``tox``

        .. code-block:: yaml
        
            - name: Deploy
              if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
              uses: JamesIves/github-pages-deploy-action@4.3.0
              with:
                token: ${{ secrets.DEPLOY_DOCS_PAT }}
                repository-name: pyansys/repository-name
                branch: gh-pages
                folder: .tox/doc_out
                clean: true

    .. group-tab:: Without Using ``tox``

        .. code-block:: yaml

            - name: Deploy
              if: github.event_name == 'push' && contains(github.ref, 'refs/tags')
              uses: JamesIves/github-pages-deploy-action@4.3.0
              with:
                token: ${{ secrets.DEPLOY_DOCS_PAT }}
                repository-name: pyansys/repository-name
                branch: gh-pages
                folder: doc/_build/html
                clean: true



Deploying when Tagging
++++++++++++++++++++++

Depending on your preferences, you may choose to update the documentation on
tags only (as done above), or on each each push. If you wish to have your
documentation deployed on each push to ``main``, change the conditional above
to:

.. code-block:: yaml

    if: github.ref == 'refs/heads/main'


Accessing Online Documentation
------------------------------
Documentation for the latest stable release of a PyAnsys library is accessible
from its repository. You can generally access the latest development version of
the documentation tracking the ``main`` branch by adding the prefix ``dev.`` to
the URL for the latest stable release.

For example, consider PyAEDT documentation:

- The URL for documentation of the latest stable release is `<https://aedtdocs.pyansys.com/>`_.
- The URL for documentation of the latest development version is `<https://dev.aedtdocs.pyansys.com/>`_.

The latest development versions of both the library and its documentation are
automatically kept up-to-date via GitHub actions.

To make documentation changes, you create a branch with a name that begins with
a prefix of ``doc/`` that is then followed by a short description of what you
are changing. For more information, see :ref:`Branching Model`.

As you are making changes in this branch, you want to periodically generate the
documentation locally so that you can test your changes before you create a
GitHub pull request. For more information, see :ref:`Building Documentation`.


..
   Links

.. _GitHub Pages: https://pages.github.com/
.. _GitHub Actions: https://github.com/features/actions
.. _PyMAPDL Documentation: https://mapdldocs.pyansys.com/
.. _pyansys/pymapdl-docs: https://github.com/pyansys/pymapdl-docs
.. _gh-pages: https://github.com/pyansys/dev-guide/tree/gh-pages
.. _enabling GitHub pages: https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site#creating-your-site
.. _tox: https://github.com/tox-dev/tox
.. _PyAnsys DNS Zones: https://portal.azure.com/#@ansys.com/resource/subscriptions/2870ae10-53f8-46b1-8971-93761377c38b/resourceGroups/pyansys/providers/Microsoft.Network/dnszones/pyansys.com/overview
.. _Maxime Rey: https://teams.microsoft.com/l/chat/0/0?users=maxime.rey@ansys.com
.. _Roberto Pastor Muela: https://teams.microsoft.com/l/chat/0/0?users=roberto.pastormuela@ansys.com
.. _Alex Kaszynski: https://teams.microsoft.com/l/chat/0/0?users=alexander.kaszynski@ansys.com
.. _PyAnsys Bot: https://github.com/apps/pyansys-bot
.. _PyAnsys Organization: https://github.com/pyansys
.. _ansys-templates: https://github.com/pyansys/ansys-templates
